const crypto = require('crypto');
const Order = require('../models/Orders');
const Transaction = require('../models/Transaction');
const Restaurant = require('../models/Restaurant');

// ‚úÖ Initialize global payment status store
if (!global.paymentStatusStore) {
    global.paymentStatusStore = new Map();
}

// ‚úÖ Main webhook handler
const handleWebhook = async (req, res) => {
    try {
        console.log('üîî Webhook received:', req.body);
        
        // ‚úÖ FIX: Handle Xendit's actual webhook format
        const webhookData = req.body;
        
        // ‚úÖ Check if this is a payment success webhook
        if (webhookData.status === 'PAID' && webhookData.external_id) {
            console.log('‚úÖ Processing payment success webhook');
            await handleInvoicePaid(webhookData);
        } else if (webhookData.event === 'invoice.paid') {
            // ‚úÖ Also handle the event-based format
            console.log('‚úÖ Processing invoice.paid event');
            await handleInvoicePaid(webhookData.data || webhookData);
        } else {
            console.log('‚ö†Ô∏è Unknown webhook format:', {
                status: webhookData.status,
                event: webhookData.event,
                external_id: webhookData.external_id
            });
        }
        
        // ‚úÖ Always respond with 200 to acknowledge receipt
        res.status(200).json({ status: 'OK' });
    } catch (error) {
        console.error('‚ùå Webhook error:', error);
        // ‚úÖ Still respond with 200 to prevent retries
        res.status(200).json({ status: 'Error processed' });
    }
};

async function handleInvoicePaid(data) {
    try {
        console.log('‚úÖ Webhook: Processing payment success for:', data.external_id);
        
        // ‚úÖ Store payment success status
        global.paymentStatusStore.set(data.external_id, {
            status: 'PAID',
            timestamp: new Date(),
            invoiceId: data.id,
            paymentMethod: data.payment_method,
            amount: data.amount,
            isConfirmed: true,
            webhookData: {
                payment_id: data.payment_id,
                payment_method_id: data.payment_method_id,
                ewallet_type: data.ewallet_type,
                merchant_name: data.merchant_name
            }
        });

        // ‚úÖ ADD THIS: Also store in database for persistence
        try {
            await Transaction.findOneAndUpdate(
                { xenditInvoiceId: data.id },
                { 
                    'xenditData.payment_id': data.payment_id,
                    'xenditData.payment_method_id': data.payment_method_id,
                    'xenditData.ewallet_type': data.ewallet_type,
                    'xenditData.merchant_name': data.merchant_name
                },
                { upsert: true }
            );
            console.log('‚úÖ Webhook data stored in database for persistence');
        } catch (error) {
            console.log('‚ö†Ô∏è Could not store webhook data in database:', error.message);
        }

        console.log('‚úÖ Webhook: Payment status stored in global store');
        console.log('‚úÖ Store size after storing:', global.paymentStatusStore.size);
        console.log('‚úÖ Available keys:', Array.from(global.paymentStatusStore.keys()));

        // ‚úÖ Clean up old entries after 15 minutes
        setTimeout(() => {
            global.paymentStatusStore.delete(data.external_id);
            console.log('‚úÖ Cleaned up payment status for:', data.external_id);
        }, 15 * 60 * 1000);

        // ‚úÖ Also update the Order if it exists
        if (transaction.orderId) {
            await Order.findByIdAndUpdate(
                transaction.orderId,
                { paymentStatus: 'PAID' } // ‚úÖ CHANGE FROM 'Completed' TO 'PAID'
            );
            console.log('‚úÖ Webhook: Order payment status updated');
        }

        console.log('‚úÖ Webhook: Payment status stored successfully');
    } catch (error) {
        console.error('‚ùå Webhook: Error handling invoice paid:', error);
    }
}

module.exports = {
    handleWebhook
};